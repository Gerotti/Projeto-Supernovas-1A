# -*- coding: utf-8 -*-
"""SN1aParte1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wgzQYGvQGNJnJCdDrA1kgFvqoskjRsSv

# Projeto Supernovas Ia

* Bruno S. Gerotti - 10301280

* Vitor M. Cernic - 9847710

---



## 1. Introdução

Para a parte computacional vamos fazer códigos em Python3. Como é necessário em algum momento calcular uma integral, vamos utilizar a função ***quad*** da biblioteca ***scipy.integrate***. Essa função calcula uma integral numérica pelo método de quadratura. Abaixo vamos testar ela para uma gaussiana.
"""

import numpy as np
from math import sqrt
from scipy.integrate import quad

#definindo uma funcao gaussiana pra integrar
def gauss(x, a, b, c):
  return a*np.exp(-(x-b)**2/(2*c**2))

#a integral da gaussiana entre +- infinito deve ser igual: a*c*sqrt(2*pi)
a = 1
b = 2
c = 3
I = quad(gauss, -np.inf, +np.inf, args=(a,b,c))
print('Valor da integral: ', I[0], ' | Erro: ', I[1])
print('Valor que deveria ser: ', a*c*sqrt(2*np.pi))
print('Teste z: ', (I[0]-a*c*sqrt(2*np.pi))/I[1])

"""A integral funciona super bem para um exemplo comum. Vamos agora testar para o caso onde vamos realmente aplicá-la.

---


## 2. Teste da integral numérica para $\frac{1}{E(z)}$

Aqui vamos testar o quão bom é a intergral numérica de $\frac{1}{E(z')}dz'$ para diferentes casos. Vamos estudar 3 casos diferentes onde podemos calcular essa integral analíticamente:



---



1.   **Só matéria**

Caso o Universo seja feito só de matéria, temos que:

$ \Omega_M = 1 ; \Omega_\Lambda = 0 ;  \Omega_k = 0 $

Assim, podemos calcular a integral:

$\int_{0}^{z} \frac{1}{E(z')}dz' = \int_{0}^{z} \frac{1}{(1+z')^{\frac{3}{2}}} dz' = 2-\frac{2}{\sqrt(1+z)}$



---



2.   **Só Energia Escura**

Se só tivermos energia escura e com um $w = -1$ :

$ \Omega_M = 0 ; \Omega_\Lambda = 1 ;  \Omega_k = 0 $

Então a integral fica:

$ \int_{0}^{z} \frac{1}{E(z')}dz' = \int_{0}^{z} dz' = z $



---



3. **Universo Vazio**

Se o Universo não tiver nem matéria nem energia escura:

$ \Omega_M = 0 ; \Omega_\Lambda = 0 ;  \Omega_k = 1 $

Temos que:

$\int_{0}^{z} \frac{1}{E(z')}dz' = \int_{0}^{z} \frac{1}{1+z'} dz' = \log(1+z)$


---

Vamos começar definindo uma função *teste_E* para testar a integral.
"""

# ignorando runtimewarinings
import warnings
warnings.filterwarnings('ignore')

# testando a integral da funcao E
def teste_E(z, omegaM, omegaEE):
  omegaK = 1-omegaM-omegaEE
  w = -1
  def E(zz):
    return 1/(sqrt(omegaM*(1+zz)**3 + omegaEE*(1+zz)**(3*(1+w)) + omegaK*(1+zz)**2))
  return quad(E, 0, z) #retorna a integral

"""Agora podemos calcular tanto essa integral quanto os resultados analíticos em diferentes valores de *z*. Nesse caso, vamos calcular para 10 valores de *z* entre 1 e 10."""

# so materia (omegaM = 1, omegaEE = 0, omegaK = 0)
# so energia escura (omegaM = 0, omegaEE = 1, omegaK = 0)
# universo vazio (omegaM = 0, omegaEE = 0, omegaK = 1)
materia, energiaescura, vazio = [], [], []

# vou calcular para 10 valores diferentes de z
for z in range(1, 11):
  # materia
  aprox = teste_E(z, omegaM=1, omegaEE=0)
  anali = 2-2/sqrt(z+1)
  testez = abs(aprox[0]-anali)/aprox[1]
  materia.insert(len(materia), {'z': z, 'aproximacao': aprox[0], 'erro': aprox[1], 'analitico': anali, 'teste-z': testez})

  # energia escura
  aprox = teste_E(z, omegaM=0, omegaEE=1)
  anali = float(z)  # para w=-1
  testez = abs(aprox[0]-anali)/aprox[1]
  energiaescura.insert(len(energiaescura), {'z': z, 'aproximacao': aprox[0], 'erro': aprox[1], 'analitico': anali, 'teste-z': testez})

  # vazio
  aprox = teste_E(z, omegaM=0, omegaEE=0)
  anali = np.log(z+1)
  testez = abs(aprox[0]-anali)/aprox[1]
  vazio.insert(len(vazio), {'z': z, 'aproximacao': aprox[0], 'erro': aprox[1], 'analitico': anali, 'teste-z': testez})

# colocando em forma de dataframe pra ficar mais facil de ver em tabelas
import pandas as pd
materia = pd.DataFrame(materia)
energiaescura = pd.DataFrame(energiaescura)
vazio = pd.DataFrame(materia)

"""Agora podemos apresentar os resultados. Vamos mostrá-los em forma de tabela para ficar mais fácil a comparação entre os valores aproximados pela integral e os cálculos analíticos."""

print('###########   Só matéria   ###########')
display(materia)

print('###########   Só energia escura   ###########')
display(energiaescura)

print('###########   Universo vazio   ###########')
display(vazio)

"""Podemos ver que em todas as comparações o teste-z foi sempre muito baixo, assim como o erro. Podemos dizer que esse método numérico para resolver a integral funcionou muito bem.

---


## 3. Criando uma função geral

Sabendo que a integral de $\frac{1}{E(z)}$ é bem aproximada numericamente, podemos criar uma função geral que calcule o valor da distância de luminosidade $d_L$ e do módulo de distância $\mu$.
"""

def func(z, H0, omegaM, omegaEE, w):

  # calculo do omegaK
  omegaK = 1 - omegaM - omegaEE  

  # definimos a funcao 1/E(z)
  def E(zz):
    return 1/(sqrt(omegaM*(1+zz)**3 + omegaEE*(1+zz)**(3*(1+w)) + omegaK*(1+zz)**2))
  # distancia de Hubble
  dH = c/H0
  # distancia comovel
  dC = dH*quad(E, 0, z)[0]

  # para calcular a distancia comovel transversa devemos analisar omegaK
  if omegaK > 0:
    dM = dH/sqrt(omegaK)*np.sinh(sqrt(omegaK)*dC/dH)
  elif omegaK == 0:
    dM = dC
  elif omegaK < 0:
    dM = dH/sqrt(abs(omegaK))*np.sin(sqrt(abs(omegaK))*dC/dH)

  # podemos calcular a distancia de luminosidade finalmente
  dL = (1+z)*dM

  # o modulo de distancias em Mpc
  mu = 5*np.log10(dL) + 25

  return dL, mu

"""---

## 4. Como $(\frac{H_0}{c})d_L$ varia com $z$.

Podemos agora aplicar a função acima para diferentes redshifts e estudar como  *z* varia em diferentes Universos. 

Primeiramente, vamos estudar como $(\frac{H_0}{c})d_L$ varia com $z$.
"""

# definindo as constantes c, G e H0 para serem usadas em qualquer lugar
# H0 ainda pode ser variado se for passado outro valor como parametro da funcao
global c, H0
c = 299792.458 #km/s
H0 = 73 #COSMOGRAIL 2020

materia, benchmark, energiaescura = [], [], []
z_vec = np.linspace(0,6,1000) # vamos calcular para 1000 pontos

for z in z_vec:
  # so materia
  materia.append((H0/c)*func(z, H0, omegaM = 1, omegaEE = 0, w = -1)[0])

  # so energia escura
  energiaescura.append((H0/c)*func(z, H0, omegaM = 0, omegaEE = 1, w = -1)[0])

  # benchmark
  benchmark.append((H0/c)*func(z, H0, omegaM = 0.3, omegaEE = 0.7, w = -1)[0])

# plotando os resultados
import matplotlib.pyplot as plt

fig = plt.figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
ax = fig.add_subplot(111)
plt.plot(z_vec, materia, 'r--', label='materia')
plt.plot(z_vec, energiaescura, 'b-.', label='energia escura')
plt.plot(z_vec, benchmark, 'g-', label='benchmark')
plt.xlim(0,6)
plt.ylim(0,15.4)
plt.ylabel(r'$(H_0/c) d_L$', fontsize=20)
plt.xlabel('z', fontsize=20)
plt.rcParams.update({'font.size': 10})
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
ax.text(3.3, 10, r'Benchmark',color= 'g', fontsize=15)
ax.text(4.5, 5, r'matter-only', color= 'r', fontsize=15)
ax.text(2.5, 14.5, r'$\Lambda$-only', color='b', fontsize=15)
plt.show()

"""---

## 5. Aproximação de $d_L$

Vamos comparar uma aproximação para $d_L$ com os resultados obtidos anteriormente. Essa aproximação é da forma:

$ d_L \approx \frac{c}{H_0} z (1+ \frac{1-q_0}{2} z) $

Definindo essa função:
"""

# definindo a funcao que aproxima dL
def aprox_dL(z, H0, omegaM, omegaEE):
  q0 = 1/2*omegaM - omegaEE
  return (c/H0)*z*(1+z*(1-q0)/2)

global c, H0
c = 299792.458 #km/s
H0 = 70 #COSMOGRAIL 2020

aprox_dL(0.15, H0, 0.1, 0.9)

func(0.15, H0, 0.1, 0.9, -1)

"""Agora vamos calcular essa aproximação para diferentes valores de *z*."""

# vamos calcular para os mesmos casos de antes (materia, energia escura e benchmark)
m_aprox, b_aprox, e_aprox = [], [], []
z_vec = np.linspace(0,6,1000) # vamos calcular para 1000 pontos

for z in z_vec:
  # so materia
  m_aprox.append((H0/c)*aprox_dL(z, H0, omegaM = 1, omegaEE = 0))

  # so energia escura
  e_aprox.append((H0/c)*aprox_dL(z, H0, omegaM = 0, omegaEE = 1))

  # benchmark
  b_aprox.append((H0/c)*aprox_dL(z, H0, omegaM = 0.3, omegaEE = 0.7))

# plotando comparando com o outro resultado
fig = plt.figure(num=None, figsize=(8, 6), dpi=80, facecolor='w', edgecolor='k')
ax = fig.add_subplot(111)

plt.plot(z_vec, materia, 'r-', label='materia ñ aprox')
plt.plot(z_vec, m_aprox, '--', color='r', label='aprox materia')
plt.plot(z_vec, energiaescura, 'b-', label='EE ñ aprox')
plt.plot(z_vec, e_aprox, '--', color='b', label='aprox EE')
plt.plot(z_vec, benchmark, 'g-', label='bechmark ñ aprox')
plt.plot(z_vec, b_aprox, '--', color='g', label='aprox benchmark')

plt.xlim(0,6)
plt.ylim(0,15.4)
plt.ylabel(r'$(H_0/c) d_L$', fontsize=20)
plt.xlabel('z', fontsize=20)
plt.rcParams.update({'font.size': 10})
plt.xticks(fontsize=15)
plt.yticks(fontsize=15)
ax.text(3.3, 10, r'Benchmark',color= 'g', fontsize=15)
ax.text(4.5, 5, r'matter-only', color= 'r', fontsize=15)
ax.text(2.5, 14.5, r'$\Lambda$-only', color='b', fontsize=15)
plt.legend()
plt.show()

"""---

## 6. Magnitude aparente para diferentes Universos

Por definição, o módulo de distâncias é dado por:

$\mu = m - M \Rightarrow m = \mu + M $

Ou seja, tendo a magnitude absoluta e o módulo de distâncias, podemos encontrar a magnitude aparente. 

![tabela](https://drive.google.com/uc?id=1enYLkHtWF6mSbbArm4PAdbeoV4wh4Uuu)

Portanto, podemos calcular a magnitude aparente de todos os objetos dessa tabela, sabendo que $z=1$ e $M=-19.05$.
"""

# calculando a magnitude aparente para cada objeto da tabela
magaparente = []
# calcula-se a mag na ordem da tabela
magaparente.append(-21.5 + func(z=0.15, H0=70, omegaM=0.1  , omegaEE=0.9  , w=-1  )[1])
magaparente.append(-19.05 + func(z=1, H0=H0, omegaM=0.3, omegaEE=0  , w=-1  )[1])
magaparente.append(-19.05 + func(z=1, H0=H0, omegaM=0.3, omegaEE=0.7, w=-1  )[1])
magaparente.append(-19.05 + func(z=1, H0=H0, omegaM=0.3, omegaEE=0.7, w=-0.8)[1])
magaparente.append(-19.05 + func(z=1, H0=H0, omegaM=0.3, omegaEE=0.7, w=-1.2)[1])

#printando os resultados em tabela formatada
from tabulate import tabulate

table = [[1.0, 0.0, '--', 'Einstein - de Sitter', magaparente[0]],
         [0.3, 0.0, '--', 'Aberto'              , magaparente[1]],
         [0.3, 0.7, -1.0, 'Padrão'              , magaparente[2]],
         [0.3, 0.7, -0.8, '--'                  , magaparente[3]],
         [0.3, 0.7, -1.2, '--'                  , magaparente[4]]]

print(tabulate(table,
               headers=['Omega_M', 'Omega_EE', 'w', 'Nome', 'Magnitude Aparente'], 
               tablefmt='github',
               numalign='center',
               stralign='center'))